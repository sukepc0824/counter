<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>colony counter</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
  }
  #controls {
    margin-bottom: 1em;
	display: flex;
	align-items: center;
	justify-content:	center ;
	gap: 10px;
  }
  #counter {
    font-size: 1.2em;
  }
  #imageWrapper {
    position: relative;
    display: inline-block;
    max-width: 100%;
    touch-action: manipulation; /* スクロールやズームを抑制しない */
  }
  #mainImg {
    width: 100vw;
    height: auto;
    display: block;
  }
  .marker {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(255, 0, 0, 0.8);
    border: 2px solid #fff;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }
  button, input[type="file"] {
    font-size: 1.2em;
    margin: 0 0.5em;
  }
</style>
</head>
<body>
  <div id="controls">
    <input type="file" id="imgInput" accept="image/*">
	数:
	<div id="counter"><span id="count">0</span></div>
	大きさ:
	<input type="range" name="size" id="sizeInput" value="10" min="2" max="18">
	<button id="undoBtn">戻る</button>
  </div>
  <div id="imageWrapper">
    <img id="mainImg" src="" alt="">
  </div>

<script>
const imgInput = document.getElementById('imgInput');
const mainImg = document.getElementById('mainImg');
const wrapper = document.getElementById('imageWrapper');
const countSpan = document.getElementById('count');
const undoBtn = document.getElementById('undoBtn');
const sizeInput = document.getElementById('sizeInput');

let markers = [];
let startPos = null;
let moved = false;
let tempMarker = null;

// 画像選択
imgInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    mainImg.src = ev.target.result;
    markers = [];
    clearMarkers();
    updateCount();
  };
  reader.readAsDataURL(file);
});

function clearMarkers() {
  wrapper.querySelectorAll('.marker').forEach(m => m.remove());
}

function updateCount() {
  countSpan.textContent = markers.length;
}

// === マーカー描画関数 ===
function createMarker(xPercent, yPercent) {
  const marker = document.createElement('div');
  marker.className = 'marker';
  marker.style.width = sizeInput.value + 'px';
  marker.style.height = sizeInput.value + 'px';
  marker.style.left = `${xPercent}%`;
  marker.style.top = `${yPercent}%`;
  wrapper.appendChild(marker);
  return marker;
}

// === ポインタ操作 ===
wrapper.addEventListener('pointerdown', e => {
  if (!mainImg.src) return;
  if (e.pointerType === 'mouse' && e.button !== 0) return; // 右クリック除外
  if (!e.isPrimary) return; // 複数指操作除外

  const rect = mainImg.getBoundingClientRect();
  const xPercent = ((e.clientX - rect.left) / rect.width) * 100;
  const yPercent = ((e.clientY - rect.top) / rect.height) * 100;

  // 押した瞬間にマーカー作成
  tempMarker = createMarker(xPercent, yPercent);
  startPos = { x: e.clientX, y: e.clientY };
  moved = false;
});

wrapper.addEventListener('pointermove', e => {
  if (!startPos) return;
  const dx = e.clientX - startPos.x;
  const dy = e.clientY - startPos.y;
  if (Math.sqrt(dx*dx + dy*dy) > 10) {
    moved = true;
    // スクロールなどと判定されたらマーカー削除（キャンセル）
    if (tempMarker) {
      tempMarker.remove();
      tempMarker = null;
    }
  }
});

wrapper.addEventListener('pointerup', e => {
  if (!mainImg.src || !startPos) return;
  e.preventDefault();

  if (!moved && tempMarker) {
    // 有効なクリックと判定
    const rect = mainImg.getBoundingClientRect();
    const xPercent = ((e.clientX - rect.left) / rect.width) * 100;
    const yPercent = ((e.clientY - rect.top) / rect.height) * 100;
    markers.push({ x: xPercent, y: yPercent });
    updateCount();
    tempMarker = null;
  } else if (moved && tempMarker) {
    // 移動していた場合はマーカー削除
    tempMarker.remove();
    tempMarker = null;
  }
  startPos = null;
});

// サイズ変更時に既存マーカー更新
sizeInput.addEventListener('input', e => {
  document.querySelectorAll('.marker').forEach(el => {
    el.style.width = sizeInput.value + 'px';
    el.style.height = sizeInput.value + 'px';
  });
});

// 戻るボタン
undoBtn.addEventListener('click', () => {
  if (markers.length === 0) return;
  markers.pop();
  const lastMarker = wrapper.querySelector('.marker:last-of-type');
  if (lastMarker) lastMarker.remove();
  updateCount();
})
</script>
</body>
</html>
